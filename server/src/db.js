const { seedCustomers } = require("./seedData");

async function migrate(pool) {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS products (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name TEXT NOT NULL,
      category TEXT NOT NULL,
      price NUMERIC NOT NULL,
      stock INTEGER NOT NULL,
      needed INTEGER NOT NULL DEFAULT 0,
      status TEXT NOT NULL DEFAULT 'full',
      scope TEXT NOT NULL DEFAULT 'items'
    );
    CREATE TABLE IF NOT EXISTS customers (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      first_name TEXT NOT NULL,
      last_name TEXT NOT NULL,
      position TEXT,
      mobile TEXT
    );
    CREATE TABLE IF NOT EXISTS orders (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      customer_id INTEGER NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
    CREATE TABLE IF NOT EXISTS order_items (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
      product_id INTEGER NOT NULL REFERENCES products(id),
      quantity INTEGER NOT NULL
    );
  `);
  await pool.query(`
    ALTER TABLE products
    ADD COLUMN IF NOT EXISTS needed INTEGER NOT NULL DEFAULT 0
  `);
  await pool.query(`
    ALTER TABLE products
    ADD COLUMN IF NOT EXISTS status TEXT NOT NULL DEFAULT 'active'
  `);
  await pool.query(`
    ALTER TABLE products
    ALTER COLUMN status SET DEFAULT 'full'
  `);
  await pool.query(`
    ALTER TABLE products
    ADD COLUMN IF NOT EXISTS scope TEXT NOT NULL DEFAULT 'items'
  `);
  await pool.query(`
    UPDATE products
    SET scope = 'items'
    WHERE scope IS NULL
  `);
}

async function seed(pool) {
  const customerCountResult = await pool.query(
    "SELECT COUNT(*)::int AS count FROM customers"
  );
  if (customerCountResult.rows[0].count > 0) {
    return;
  }

  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    for (const customer of seedCustomers) {
      await client.query(
        `
          INSERT INTO customers (id, first_name, last_name, position, mobile)
          VALUES ($1, $2, $3, $4, $5)
          ON CONFLICT (id) DO NOTHING
        `,
        [
          customer.id,
          customer.firstName,
          customer.lastName,
          customer.position,
          customer.mobile
        ]
      );
    }

    await client.query("COMMIT");
  } catch (error) {
    await client.query("ROLLBACK");
    throw error;
  } finally {
    client.release();
  }

}

async function syncSequences(pool) {
  await pool.query(
    `
      SELECT setval(
        pg_get_serial_sequence('products', 'id'),
        (SELECT COALESCE(MAX(id), 1) FROM products)
      )
    `
  );
  await pool.query(
    `
      SELECT setval(
        pg_get_serial_sequence('customers', 'id'),
        (SELECT COALESCE(MAX(id), 1) FROM customers)
      )
    `
  );
  await pool.query(
    `
      SELECT setval(
        pg_get_serial_sequence('orders', 'id'),
        (SELECT COALESCE(MAX(id), 1) FROM orders)
      )
    `
  );
}

async function initDb(pool) {
  await migrate(pool);
  await seed(pool);
  await syncSequences(pool);
  await pool.query(
    `
      UPDATE customers
      SET first_name = 'Justin',
          last_name = 'Faciane'
      WHERE first_name = 'ADMI' AND last_name = 'ZAKARYAE'
    `
  );
}

module.exports = { initDb };
